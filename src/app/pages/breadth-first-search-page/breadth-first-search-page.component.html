<div class="mt-5"></div>
<div class="introduction">

    <div class="text-part">
        <h2>Breadth First Seach</h2>
        <p>
            Breadth first search is an algorithm for graph traversal,
            to make it easy to understand this algorithm is responsible for traversing a graph and find a certain value.
            But for you to understand much better first let's review what a graph is and why it is useful. 
        </p>
    </div>

    <div class="text-part">
        <h3>What is a graph and Why this is useful?</h3>
        <p>
            A graph consists of a set of nodes or vertices connected by edges. An edge consists of a pair of vertices.
            For example, if we establish a pair between two vertices, 
            A and B, we refer to this related pair as an edge. Since they are connected by an edge, A and B are adjacent. This is useful because
            provides answers to many arrangement, optimization and much more. For example we can use the graph for modeling network topology,
            such as your friends on Instagram or the internet or for determining an optimal path in a GPS
        </p>
        <br>
        <p>This is an example of a graph:</p>
        <img class="example-graph" src="https://res.cloudinary.com/adivinity/image/upload/v1649212940/Example_Graph_cgbbso.jpg" alt="example">

    </div>

    <div class="text-part">
        <h3>How does the algorithm work?</h3>
        <p>
            Now understanding what is a graph and its uses, let's continue with the explanation of how this algorithm works,
            the first thing is that the algorithm takes a root value that can be any and this will be where the algorithm will start to traverse
            the graph and second we have to put a goal which will be the value we want to find in the graph. for example if the graph has 3 letters A,
            B and C and A is connected to B and B is connected to C and we specify that A will be the root value and C the goal,
            then the algorithm will start to add to a queue the nodes that it visits, in the first case it would be A and as A is not C which is the goal,
            then it continues searching, passing by the next node which will be connected by an edge in this case the only node that is connected to A would be
            B so it passes to B and as B is not C, then it continues searching and so on until it finds the target.
            Below you can see an animation which explains how this works in a visual way.
        </p>
    </div>

    
    <app-breadth-first-search-animation></app-breadth-first-search-animation>


    <div class="mt-2"></div>

    <div class="text-part">

        <h3>Code:</h3>

        <h4>We need to create a class:</h4>
        <br>

        <div class="code-part">

            <p>class Graph {{'{'}}</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;constructor() {{'{'}}</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nodes = [];</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.adjacent = {{'{'}}{{'}'}};</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.edges = 0;</p>
            <p>&nbsp;&nbsp;&nbsp;{{'}'}}</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;addNode(n) {{'{'}}</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.nodes.push(n);</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.adjacent[n] = [];</p>
            <p>&nbsp;&nbsp;&nbsp;{{'}'}}</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;addEdge(n, w) {{'{'}}</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.adjacent[n].push(w);</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.adjacent[w].push(n);</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.edges++;</p>
            <p>&nbsp;&nbsp;&nbsp;{{'}'}}</p>
            <br>
            <p>{{'}'}}</p>

        </div>

        <h4>Now let's initialize a new Graph and add nodes and edges</h4>
        <br>

        <div class="code-part">
            <p>const graph = new Graph();</p>
            <br>
            <p>// here we add the same nodes as in the animation we used to visually show how the algorithm works </p>
            <br>
            <p>graph.addNode(1);</p>
            <p>graph.addNode(2);</p>
            <p>graph.addNode(3);</p>
            <p>graph.addNode(4);</p>
            <p>graph.addNode(5);</p>
            <p>graph.addNode(6);</p>
            <br>
            <p>graph.addEdge(1,5);</p>
            <p>graph.addEdge(1,2);</p>
            <p>graph.addEdge(5,2);</p>
            <p>graph.addEdge(5,6);</p>
            <p>graph.addEdge(2,4);</p>
            <p>graph.addEdge(2,3);</p>
            <p>graph.addEdge(4,3);</p>
            <p>graph.addEdge(4,6);</p>
        </div>

        <h4>The BFS function:</h4>
        <br>

        <div class="code-part">

            <p>bfs( goal, root = this.nodes[0] ) {{'{'}}</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;let adj = this.adjacent;</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;const queue = [];</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;queue.push(root);</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;const discoveredNodes = [];</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;discoveredNodes[root] = true;</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;while(queue.length) {{'{'}}</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let n = queue.shift();</p>
            <br>
            <br>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (n === goal) {{'{'}}</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{'}'}}</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i < adj[n].length; i++) {{'{'}}</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!discoveredNodes[adj[n][i]]) {{'{'}}</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;discoveredNodes[adj[n][i]] = true;</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;queue.push(adj[n][i]);</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{'}'}}</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{{'}'}}</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;{{'}'}}</p>
            <br>
            <p>&nbsp;&nbsp;&nbsp;return false;</p>
            <br>
            <p>{{'}'}}</p>

        </div>

    </div>

        
</div>

